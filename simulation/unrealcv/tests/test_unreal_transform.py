import unittest
import numpy as np
import transforms3d as tf
import util.transform as mytf
import simulation.unrealcv.unreal_transform as uetrans


class TestToAndFromUnreal(unittest.TestCase):

    def test_point_to_unreal(self):
        point = (13, -7, 156)
        ue_point = uetrans.transform_to_unreal(point)
        self.assert_array((13, 156, -7), ue_point)

    def test_pose_to_unreal(self):
        pose = mytf.Transform(location=(37, 113, -97),
                              rotation=tf.quaternions.axangle2quat((1,2,3), np.pi/4), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_array((37, -97, 113), ue_pose.location)
        # This rotation was generated by Unreal, when asked to rotate around the same axis
        # I used Rotator from Axis Angle given 1 Forward, 2 Up, and 3 Right, and 45 degrees
        self.assert_close((-31.675301, 31.189531, -21.688360), ue_pose.euler)

    def test_roll_to_unreal(self):
        # This pose is rotated 45 degrees clockwise around X
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((1, 0, 0), np.pi / 4), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((-45, 0, 0), ue_pose.euler)

        # And this is 30 degrees anticlockwise around X
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((1, 0, 0), -np.pi / 6), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((30, 0, 0), ue_pose.euler)

    def test_pitch_to_unreal(self):
        # This pose is rotated 45 degrees clockwise around right (Z)
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((0, 0, 1), np.pi / 4), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((0, -45, 0), ue_pose.euler)

        # This pose is rotated 30 degrees anticlockwise around right (Z)
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((0, 0, 1), -np.pi / 6), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((0, 30, 0), ue_pose.euler)

    def test_yaw_to_unreal(self):
        # This pose is rotated 45 degrees clockwise around up (Y in my coordinate frame)
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((0, 1, 0), np.pi / 4), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((0, 0, 45), ue_pose.euler)

        # This pose is rotated 30 degrees anticlockwise around up
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((0, 1, 0), - np.pi / 6), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((0, 0, -30), ue_pose.euler)

    def test_to_and_from_unreal_is_reflexive_for_transforms(self):
        pose = mytf.Transform((-19, -23, 300), (0.6, -0.7, -0.3, 1.4))
        ue_pose = uetrans.transform_to_unreal(pose)
        pose_prime = uetrans.transform_from_unreal(ue_pose)
        self.assert_array(pose.location, pose_prime.location)
        self.assert_array(pose.rotation_quat(), pose_prime.rotation_quat())

        for i in range(10):
            ue_pose = uetrans.transform_to_unreal(pose_prime)
            pose_prime = uetrans.transform_from_unreal(ue_pose)

            self.assert_array(pose.location, pose_prime.location)
            self.assert_array(pose.rotation_quat(), pose_prime.rotation_quat())

    def test_to_and_from_unreal_is_reflexive_for_points(self):
        point = (125, -73, 403)
        ue_point = uetrans.transform_to_unreal(point)
        point_prime = uetrans.transform_from_unreal(ue_point)
        self.assert_array(point, point_prime)

        for i in range(10):
            ue_point = uetrans.transform_to_unreal(point_prime)
            point_prime = uetrans.transform_from_unreal(ue_point)
            self.assert_array(point, point_prime)

    def test_to_and_from_unreal_interchangable_point_and_pose(self):
        point = (125, -73, 403)
        pose = mytf.Transform((-19, -23, 300), (0.6, -0.7, -0.3, 1.4))

        ue_point = uetrans.transform_to_unreal(point)
        ue_pose = uetrans.transform_to_unreal(pose)

        ue_point_trans = uetrans.UnrealTransform(location=ue_point)
        ue_pose_point = ue_pose.location

        point_prime = uetrans.transform_from_unreal(ue_point_trans).location
        pose_prime = uetrans.transform_from_unreal(ue_pose_point)

        self.assert_array(point, point_prime)
        self.assert_array(pose.location, pose_prime)

    def test_to_unreal_preserves_changes(self):
        pose1 = mytf.Transform((73, -47, -23), (0.92387953, 0, 0.38268343, 0), w_first=True)
        pose2 = mytf.Transform((-19, 83, -61), (0.5, -0.5, 0.5, -0.5), w_first=True)
        relative_pose = pose1.find_relative(pose2)

        ue_pose1 = uetrans.transform_to_unreal(pose1)
        ue_pose2 = uetrans.transform_to_unreal(pose2)
        ue_relative_pose = ue_pose1.find_relative(ue_pose2)
        relative_pose_prime = uetrans.transform_from_unreal(ue_relative_pose)

        self.assert_array(relative_pose.location, relative_pose_prime.location)
        self.assert_array(relative_pose.rotation_quat(), relative_pose_prime.rotation_quat())

    def assert_array(self, arr1, arr2, msg=None):
        a1 = np.asarray(arr1)
        a2 = np.asarray(arr2)
        if msg is None:
            msg = "{0} is not equal to {1}".format(str(a1), str(a2))
        self.assertTrue(np.array_equal(a1, a2), msg)

    def assert_close(self, arr1, arr2, msg=None):
        a1 = np.asarray(arr1)
        a2 = np.asarray(arr2)
        if msg is None:
            msg = "{0} is not close to {1}".format(str(a1), str(a2))
        self.assertTrue(np.all(np.isclose(a1, a2)), msg)


class TestUnrealTransform(unittest.TestCase):
    """
    Tests for my Unreal Transform

    Note that all of the direct examples here have been tested in Unreal Engine 4.15,
    using "Convert Transform to Relative".
    Note also that due to bug UE-22445, the parameters are in opposite order to what they are named.
    """

    def test_constructor_clone(self):
        trans1 = uetrans.UnrealTransform(location=(1, 2, 3), rotation=(4, 5, 6))
        trans2 = uetrans.UnrealTransform(trans1)
        self.assert_array(trans1.location, trans2.location)
        self.assert_array(trans1.euler, trans2.euler)

    def test_location_basic(self):
        trans = uetrans.UnrealTransform(location=(1, 2, 3))
        self.assert_array((1, 2, 3), trans.location)

    def test_location_default(self):
        trans = uetrans.UnrealTransform()
        self.assert_array(np.zeros(3), trans.location)

    def test_location_from_homogeneous(self):
        hom = np.array([[0.80473785, -0.31061722, 0.50587936, 1],
                        [0.50587936, 0.80473785, -0.31061722, 2],
                        [-0.31061722, 0.50587936, 0.80473785, 3],
                        [0, 0, 0, 1]])
        trans = uetrans.UnrealTransform(hom)
        self.assert_array((1, 3, 2), trans.location)

    def test_rotation_basic(self):
        # The rotation here is for 45 degrees around axis 1,2,3
        trans = uetrans.UnrealTransform(location=(1, 2, 3), rotation=(142, -36, 100))
        self.assert_array((142, -36, 100), trans.euler)

    def test_rotation_default(self):
        trans = uetrans.UnrealTransform()
        self.assert_array(trans.euler, (0, 0, 0))

    def test_rotation_from_homogeneous(self):
        # Note: I generated this homogenous matrix from the angles
        hom = np.array([[0.81379768, 0.46984631, 0.34202014, 1],
                        [-0.14410968, 0.73329482, -0.66446302, 2],
                        [-0.5629971, 0.49145005, 0.66446302, 3],
                        [0, 0, 0, 1]])
        trans = uetrans.UnrealTransform(hom)
        self.assert_close(trans.euler, (45, 20, -30))

    def test_find_relative_point_moves_origin(self):
        point = (11, 12, 13)
        trans = uetrans.UnrealTransform(location=(10, 9, 8))
        point_rel = trans.find_relative(point)
        self.assert_array(point_rel, (1, 3, 5))

    def test_find_relative_pose_moves_origin(self):
        pose = uetrans.UnrealTransform(location=(11, 12, 13))
        trans = uetrans.UnrealTransform(location=(10, 9, 8))
        pose_rel = trans.find_relative(pose)
        self.assert_array((1, 3, 5), pose_rel.location)

    def test_find_relative_point_changes_location_coordinates(self):
        point = (11, 12, 13)
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(0, 0, 90))
        point_rel = trans.find_relative(point)
        self.assert_close((3, -1, 5), point_rel)

    def test_find_relative_pose_changes_location_coordinates(self):
        pose = uetrans.UnrealTransform(location=(11, 12, 13))
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(0, 0, 90))
        pose_rel = trans.find_relative(pose)
        self.assert_close((3, -1, 5), pose_rel.location)

    def test_find_relative_pose_changes_orientation(self):
        pose = uetrans.UnrealTransform(location=(11, 12, 13), rotation=(45, 0, 0))
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(0, 0, 90))
        pose_rel = trans.find_relative(pose)
        self.assert_close((45, 0, -90), pose_rel.euler)

    def test_find_independent_point_moves_origin(self):
        point = (1, 3, 5)
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(0, 0, 90))
        point_rel = trans.find_independent(point)
        self.assert_array((7, 10, 13), point_rel)

    def test_find_independent_pose_moves_origin(self):
        pose = uetrans.UnrealTransform(location=(1, 3, 5))
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(0, 0, 90))
        pose_rel = trans.find_independent(pose)
        self.assert_array((7, 10, 13), pose_rel.location)

    def test_find_independent_pose_changes_orientation(self):
        pose = uetrans.UnrealTransform(location=(1, 3, 5), rotation=(45, 30, 0))
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(0, 0, 90))
        pose_rel = trans.find_independent(pose)
        self.assert_array((45, 30, 90), pose_rel.euler)

    def test_find_relative_undoes_point(self):
        trans = uetrans.UnrealTransform(location=(-13, 27, -127), rotation=(127, -54, -89))
        point = (1, 2, 3)
        point_rel = trans.find_relative(point)
        point_prime = trans.find_independent(point_rel)
        self.assert_close(point, point_prime)

    def test_find_relative_undoes_pose(self):
        trans = uetrans.UnrealTransform(location=(-13, 27, -127), rotation=(17, -62, -163))
        pose = uetrans.UnrealTransform(location=(10, 100, -5), rotation=(-162, 56, 53))
        pose_rel = trans.find_relative(pose)
        pose_prime = trans.find_independent(pose_rel)

        self.assert_close(pose.location, pose_prime.location)
        self.assert_close(pose.euler, pose_prime.euler)

    def test_relative_pose_contains_relative_point(self):
        trans = uetrans.UnrealTransform(location=(-13, 27, -127), rotation=(184, 12, -34))
        point = np.array([41, -153, 16])
        pose = uetrans.UnrealTransform(location=point, rotation=(0, 0, 45))
        pose_rel = trans.find_relative(pose)
        point_rel = pose_rel.location
        point_prime = trans.find_independent(point_rel)
        self.assert_close(point, point_prime)

    def assert_array(self, arr1, arr2, msg=None):
        a1 = np.asarray(arr1)
        a2 = np.asarray(arr2)
        if msg is None:
            msg = "{0} is not equal to {1}".format(str(a1), str(a2))
        self.assertTrue(np.array_equal(a1, a2), msg)

    def assert_close(self, arr1, arr2, msg=None):
        a1 = np.asarray(arr1)
        a2 = np.asarray(arr2)
        if msg is None:
            msg = "{0} is not close to {1}".format(str(a1), str(a2))
        self.assertTrue(np.all(np.isclose(a1, a2)), msg)
