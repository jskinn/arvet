# Copyright (c) 2017, John Skinner
import unittest

import numpy as np
import transforms3d as tf

import util.transform as mytf
import util.unreal_transform as uetrans


class TestToAndFromUnreal(unittest.TestCase):

    def test_point_to_unreal(self):
        point = (13, -7, 156)   # 13 forward, 7 right, 156 up
        ue_point = uetrans.transform_to_unreal(point)
        self.assert_array((1300, 700, 15600), ue_point)

    def test_pose_to_unreal(self):
        pose = mytf.Transform(location=(37, 113, -97),
                              rotation=tf.quaternions.axangle2quat((1, -3, 2), -np.pi/4), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_array((3700, -11300, -9700), ue_pose.location)
        # This rotation was generated by Unreal, when asked to rotate around the same axis
        # I used Rotator from Axis Angle given 1 Forward, 2 Up, and 3 Right, and 45 degrees
        self.assert_close((-21.688360, -31.675301, 31.189531), ue_pose.euler)

    def test_roll_to_unreal(self):
        # This pose is rotated 45 degrees clockwise around X
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((1, 0, 0), np.pi / 4), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((45, 0, 0), ue_pose.euler)

        # And this is 30 degrees anticlockwise around X
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((1, 0, 0), -np.pi / 6), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((-30, 0, 0), ue_pose.euler)

    def test_pitch_to_unreal(self):
        # This pose is rotated 45 degrees clockwise around right (neg Y)
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((0, -1, 0), np.pi / 4), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((0, 45, 0), ue_pose.euler)

        # This pose is rotated 30 degrees anticlockwise around right (neg Y)
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((0, -1, 0), -np.pi / 6), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((0, -30, 0), ue_pose.euler)

    def test_yaw_to_unreal(self):
        # This pose is rotated 45 degrees clockwise around up (Z)
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((0, 0, 1), np.pi / 4), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((0, 0, -45), ue_pose.euler)

        # This pose is rotated 30 degrees anticlockwise around up
        pose = mytf.Transform(location=(0, 0, 0),
                              rotation=tf.quaternions.axangle2quat((0, 0, 1), -np.pi / 6), w_first=True)
        ue_pose = uetrans.transform_to_unreal(pose)
        self.assert_close((0, 0, 30), ue_pose.euler)

    def test_pose_from_unreal(self):
        ue_pose = uetrans.UnrealTransform(location=(37, 113, -97),
                                          rotation=(-21.688360, -31.675301, 31.189531))
        pose = uetrans.transform_from_unreal(ue_pose)
        self.assert_array((0.37, -1.13, -0.97), pose.location)
        self.assert_close(tf.quaternions.axangle2quat((1, -3, 2), -np.pi/4), pose.rotation_quat(w_first=True))

    def test_roll_from_unreal(self):
        # This pose is rotated 45 degrees clockwise around X
        ue_pose = uetrans.UnrealTransform(location=(0, 0, 0), rotation=(45, 0, 0))
        pose = uetrans.transform_from_unreal(ue_pose)
        self.assert_close(tf.quaternions.axangle2quat((1, 0, 0), np.pi / 4), pose.rotation_quat(w_first=True))

        # And this is 30 degrees anticlockwise around X
        ue_pose = uetrans.UnrealTransform(location=(0, 0, 0), rotation=(-30, 0, 0))
        pose = uetrans.transform_from_unreal(ue_pose)
        self.assert_close(tf.quaternions.axangle2quat((1, 0, 0), -np.pi / 6), pose.rotation_quat(w_first=True))

    def test_pitch_from_unreal(self):
        # This pose is rotated 45 degrees clockwise around right (neg Y)
        ue_pose = uetrans.UnrealTransform(location=(0, 0, 0), rotation=(0, 45, 0))
        pose = uetrans.transform_from_unreal(ue_pose)
        self.assert_close(tf.quaternions.axangle2quat((0, -1, 0), np.pi / 4), pose.rotation_quat(w_first=True))

        # This pose is rotated 30 degrees anticlockwise around right (neg Y)
        ue_pose = uetrans.UnrealTransform(location=(0, 0, 0), rotation=(0, -30, 0))
        pose = uetrans.transform_from_unreal(ue_pose)
        self.assert_close(tf.quaternions.axangle2quat((0, -1, 0), -np.pi / 6), pose.rotation_quat(w_first=True))

    def test_yaw_from_unreal(self):
        # This pose is rotated 45 degrees clockwise around up (Z in my coordinate frame)
        ue_pose = uetrans.UnrealTransform(location=(0, 0, 0), rotation=(0, 0, 45))
        pose = uetrans.transform_from_unreal(ue_pose)
        self.assert_close(tf.quaternions.axangle2quat((0, 0, 1), -np.pi / 4), pose.rotation_quat(w_first=True))

        # This pose is rotated 30 degrees anticlockwise around up
        ue_pose = uetrans.UnrealTransform(location=(0, 0, 0), rotation=(0, 0, -30))
        pose = uetrans.transform_from_unreal(ue_pose)
        self.assert_close(tf.quaternions.axangle2quat((0, 0, 1), np.pi / 6), pose.rotation_quat(w_first=True))

    def test_to_and_from_unreal_is_reflexive_for_transforms(self):
        pose = mytf.Transform((-19, -23, 300), (0.6, -0.7, -0.3, 1.4))
        ue_pose = uetrans.transform_to_unreal(pose)
        pose_prime = uetrans.transform_from_unreal(ue_pose)
        self.assert_array(pose.location, pose_prime.location)
        self.assert_close(pose.rotation_quat(), pose_prime.rotation_quat())

        for i in range(10):
            ue_pose = uetrans.transform_to_unreal(pose_prime)
            pose_prime = uetrans.transform_from_unreal(ue_pose)

            self.assert_array(pose.location, pose_prime.location)
            self.assert_close(pose.rotation_quat(), pose_prime.rotation_quat())

    def test_to_and_from_unreal_is_reflexive_for_points(self):
        point = (125, -73, 403)
        ue_point = uetrans.transform_to_unreal(point)
        point_prime = uetrans.transform_from_unreal(ue_point)
        self.assert_array(point, point_prime)

        for i in range(10):
            ue_point = uetrans.transform_to_unreal(point_prime)
            point_prime = uetrans.transform_from_unreal(ue_point)
            self.assert_array(point, point_prime)

    def test_to_and_from_unreal_interchangable_point_and_pose(self):
        point = (125, -73, 403)
        pose = mytf.Transform((-19, -23, 300), (0.6, -0.7, -0.3, 1.4))

        ue_point = uetrans.transform_to_unreal(point)
        ue_pose = uetrans.transform_to_unreal(pose)

        ue_point_trans = uetrans.UnrealTransform(location=ue_point)
        ue_pose_point = ue_pose.location

        point_prime = uetrans.transform_from_unreal(ue_point_trans).location
        pose_prime = uetrans.transform_from_unreal(ue_pose_point)

        self.assert_array(point, point_prime)
        self.assert_array(pose.location, pose_prime)

    def test_to_unreal_preserves_find_relative_simple(self):
        pose1 = mytf.Transform((73, -47, -23), (0.92387953, 0, 0.38268343, 0), w_first=True)
        pose2 = mytf.Transform((-19, 83, -61), (0.5, -0.5, 0.5, -0.5), w_first=True)
        relative_pose = pose1.find_relative(pose2)

        ue_pose1 = uetrans.transform_to_unreal(pose1)
        ue_pose2 = uetrans.transform_to_unreal(pose2)
        ue_relative_pose = ue_pose1.find_relative(ue_pose2)
        relative_pose_prime = uetrans.transform_from_unreal(ue_relative_pose)

        self.assert_close(relative_pose.location, relative_pose_prime.location)
        self.assert_close(relative_pose.rotation_quat(), relative_pose_prime.rotation_quat())

    def test_to_unreal_preserves_find_relative_complex(self):
        pose1 = mytf.Transform((73, -47, -23), (0.68400501,  0.37550612,  0.62456579,  0.03240183), w_first=True)
        pose2 = mytf.Transform((-19, 83, -61), (0.5, -0.5, 0.5, -0.5), w_first=True)
        relative_pose = pose1.find_relative(pose2)

        ue_pose1 = uetrans.transform_to_unreal(pose1)
        ue_pose2 = uetrans.transform_to_unreal(pose2)
        ue_relative_pose = ue_pose1.find_relative(ue_pose2)
        relative_pose_prime = uetrans.transform_from_unreal(ue_relative_pose)

        self.assert_close(relative_pose.location, relative_pose_prime.location)
        self.assert_close(relative_pose.rotation_quat(), relative_pose_prime.rotation_quat())

    def test_to_unreal_preserves_find_independent(self):
        pose1 = mytf.Transform((73, -47, -23), (0.92387953, 0, 0.38268343, 0), w_first=True)
        pose2 = mytf.Transform((-19, 83, -61), (0.5, -0.5, 0.5, -0.5), w_first=True)
        independent_pose = pose1.find_independent(pose2)

        ue_pose1 = uetrans.transform_to_unreal(pose1)
        ue_pose2 = uetrans.transform_to_unreal(pose2)
        ue_independent_pose = ue_pose1.find_independent(ue_pose2)
        independent_pose_prime = uetrans.transform_from_unreal(ue_independent_pose)

        self.assert_close(independent_pose.location, independent_pose_prime.location)
        self.assert_close(independent_pose.rotation_quat(), independent_pose_prime.rotation_quat())

    def assert_array(self, arr1, arr2, msg=None):
        a1 = np.asarray(arr1)
        a2 = np.asarray(arr2)
        if msg is None:
            msg = "{0} is not equal to {1}".format(str(a1), str(a2))
        self.assertTrue(np.array_equal(a1, a2), msg)

    def assert_close(self, arr1, arr2, msg=None):
        a1 = np.asarray(arr1)
        a2 = np.asarray(arr2)
        if msg is None:
            msg = "{0} is not close to {1}".format(str(a1), str(a2))
        self.assertTrue(np.all(np.isclose(a1, a2)), msg)


class TestUnrealTransform(unittest.TestCase):
    """
    Tests for my Unreal Transform

    Note that all of the direct examples here have been tested in Unreal Engine 4.15,
    using "Convert Transform to Relative".
    Note also that due to bug UE-22445, the parameters are in opposite order to what they are named.
    """

    def test_constructor_clone(self):
        trans1 = uetrans.UnrealTransform(location=(1, 2, 3), rotation=(4, 5, 6))
        trans2 = uetrans.UnrealTransform(trans1)
        self.assert_array(trans1.location, trans2.location)
        self.assert_array(trans1.euler, trans2.euler)

    def test_location_basic(self):
        trans = uetrans.UnrealTransform(location=(1, 2, 3))
        self.assert_array((1, 2, 3), trans.location)

    def test_location_default(self):
        trans = uetrans.UnrealTransform()
        self.assert_array(np.zeros(3), trans.location)

    def test_location_from_homogeneous(self):
        hom = tf.affines.compose(T=(1, 2, 3),
                                 R=tf.taitbryan.axangle2mat((1, 2, 3), np.pi / 9),
                                 Z=np.ones(3))
        trans = uetrans.UnrealTransform(hom)
        # homogenous is in world coordinates
        self.assert_array((100, -200, 300), trans.location)

    def test_rotation_basic(self):
        # The rotation here is for 45 degrees around axis 1,2,3
        trans = uetrans.UnrealTransform(location=(1, 2, 3), rotation=(142, -36, 100))
        self.assert_array((142, -36, 100), trans.euler)

    def test_rotation_default(self):
        trans = uetrans.UnrealTransform()
        self.assert_array(trans.euler, (0, 0, 0))

    def test_rotation_from_homogeneous(self):
        hom = tf.affines.compose(T=(1, 2, 3),
                                 R=tf.taitbryan.axangle2mat((1, -3, 2), -np.pi / 9),
                                 Z=np.ones(3))
        trans = uetrans.UnrealTransform(hom)
        # These numbers were generated using "Rotator from Axis and Angle" given the same arguments as above
        self.assert_close(trans.euler, (-6.985809, -15.403244, 11.714415))

    def test_find_relative_point_moves_origin(self):
        point = (11, 12, 13)
        trans = uetrans.UnrealTransform(location=(10, 9, 8))
        point_rel = trans.find_relative(point)
        self.assert_array(point_rel, (1, 3, 5))

    def test_find_relative_pose_moves_origin(self):
        pose = uetrans.UnrealTransform(location=(11, 12, 13), rotation=(45, 30, -30))
        trans = uetrans.UnrealTransform(location=(10, 9, 8))
        pose_rel = trans.find_relative(pose)
        self.assert_array((1, 3, 5), pose_rel.location)

    def test_find_relative_point_changes_location_coordinates(self):
        point = (11, 12, 13)
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(10, 20, 90))
        point_rel = trans.find_relative(point)
        # Limited by the precision of Unreal prints, I'm not going to worry about errors smaller than this
        self.assert_close((4.529, -1.623, 3.443), point_rel, abs_tol=0.001)

    def test_find_relative_pose_changes_location_coordinates(self):
        pose = uetrans.UnrealTransform(location=(11, 12, 13), rotation=(45, 30, -30))
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(10, 20, 90))
        pose_rel = trans.find_relative(pose)
        # Limited by the precision of Unreal prints, I'm not going to worry about errors smaller than this
        self.assert_close((4.529, -1.623, 3.443), pose_rel.location, abs_tol=0.001)

    def test_find_relative_pose_changes_orientation(self):
        pose = uetrans.UnrealTransform(location=(11, 12, 13), rotation=(45, 30, -30))
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(10, 20, 90))
        pose_rel = trans.find_relative(pose)
        self.assert_close((70.532806, 28.575809, -105.581543), pose_rel.euler)

    def test_find_independent_point_moves_origin(self):
        point = (1, 3, 5)
        trans = uetrans.UnrealTransform(location=(10, 9, 8))
        point_ind = trans.find_independent(point)
        self.assert_array((11, 12, 13), point_ind)

    def test_find_independent_pose_moves_origin(self):
        pose = uetrans.UnrealTransform(location=(1, 3, 5), rotation=(45, 30, -30))
        trans = uetrans.UnrealTransform(location=(10, 9, 8))
        pose_ind = trans.find_independent(pose)
        self.assert_array((11, 12, 13), pose_ind.location)

    def test_find_independent_point_changes_location_coordinates_simple(self):
        point = (1, 3, 5)
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(0, 0, 45))
        point_ind = trans.find_independent(point)
        self.assert_close((10 - np.sqrt(2), 9 + 2 * np.sqrt(2), 13), point_ind)

    def test_find_independent_point_changes_location_coordinates_complex(self):
        point = (1, 3, 5)
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(10, 20, 90))
        point_ind = trans.find_independent(point)
        self.assert_close((6.177, 8.434, 12.480), point_ind, abs_tol=0.001)  # Limited to the accuracy of unreal prints

    def test_find_independent_pose_changes_location_coordinates_simple(self):
        pose = uetrans.UnrealTransform(location=(1, 3, 5), rotation=(45, 30, -30))
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(0, 0, 45))
        pose_ind = trans.find_independent(pose)
        self.assert_close((10 - np.sqrt(2), 9 + 2 * np.sqrt(2), 13), pose_ind.location)

    def test_find_independent_pose_changes_location_coordinates_complex(self):
        pose = uetrans.UnrealTransform(location=(1, 3, 5), rotation=(45, 30, -30))
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(10, 20, 90))
        pose_ind = trans.find_independent(pose)
        self.assert_close((6.177, 8.434, 12.480), pose_ind.location, abs_tol=0.001)

    def test_find_independent_pose_changes_orientation(self):
        pose = uetrans.UnrealTransform(location=(1, 3, 5), rotation=(45, 30, -30))
        trans = uetrans.UnrealTransform(location=(10, 9, 8), rotation=(10, 20, 90))
        pose_ind = trans.find_independent(pose)
        self.assert_close((42.224522, 52.174339, 56.373390), pose_ind.euler)

    def test_find_relative_undoes_point(self):
        trans = uetrans.UnrealTransform(location=(-13, 27, -127), rotation=(127, -54, -89))
        point = (1, 2, 3)
        point_rel = trans.find_relative(point)
        point_prime = trans.find_independent(point_rel)
        self.assert_close(point, point_prime)

    def test_find_relative_undoes_pose(self):
        trans = uetrans.UnrealTransform(location=(-13, 27, -127), rotation=(17, -62, -163))
        pose = uetrans.UnrealTransform(location=(10, 100, -5), rotation=(-162, 56, 53))
        pose_rel = trans.find_relative(pose)
        pose_prime = trans.find_independent(pose_rel)

        self.assert_close(pose.location, pose_prime.location)
        self.assert_close(pose.euler, pose_prime.euler)

    def test_relative_pose_contains_relative_point(self):
        trans = uetrans.UnrealTransform(location=(-13, 27, -127), rotation=(184, 12, -34))
        point = np.array([41, -153, 16])
        pose = uetrans.UnrealTransform(location=point, rotation=(0, 0, 45))
        pose_rel = trans.find_relative(pose)
        point_rel = pose_rel.location
        point_prime = trans.find_independent(point_rel)
        self.assert_close(point, point_prime)

    def assert_array(self, arr1, arr2, msg=None):
        a1 = np.asarray(arr1)
        a2 = np.asarray(arr2)
        if msg is None:
            msg = "{0} is not equal to {1}".format(str(a1), str(a2))
        self.assertTrue(np.array_equal(a1, a2), msg)

    def assert_close(self, arr1, arr2, msg=None, abs_tol=1e-8, rel_tol=1e-5):
        a1 = np.asarray(arr1)
        a2 = np.asarray(arr2)
        if msg is None:
            msg = "{0} is not close to {1}".format(str(a1), str(a2))
        self.assertTrue(np.all(np.isclose(a1, a2, atol=abs_tol, rtol=rel_tol)), msg)
